# Project 2 - Clustering and Drug Discovery
## Due 02/17/2021

![BuildStatus](https://github.com/bwheel12/Project2/workflows/HW2/badge.svg?event=push)

In this assignment, you will evaluate results from a high-throughput virtual screen against the SARS-CoV2 Spike protein / Human ACE2 interface.  There are two parts to this assignment and Part 2 requires completion of Part 1. We recommend reading through both Part 1 and Part 2 before beginning this assignment. 

* Part 1 - API and implementation
* Part 2 - Evaluating clustering

The data we are considering comes from [Smith and Smith, 2020](https://chemrxiv.org/articles/preprint/Repurposing_Therapeutics_for_the_Wuhan_Coronavirus_nCov-2019_Supercomputer-Based_Docking_to_the_Viral_S_Protein_and_Human_ACE2_Interface/11871402). In this study, they generated 6 Spike-Ace2 interface poses using MD simulations. They then docked ~10k small molecules against each protein conformation. Provided for you is the top (#1) pose for each ligand docked against one Spike-ACE2 interface conformation, as well as the corresponding SMILES string, AutoDock Vina score, and the “On” bits in the Extended Connectivity Fingerprint for that compound. These can all be found in ligand\_information.csv.


### main
Runs all code in clusters/\_\_main\_\_.py, useful for part 2
```
python -m clusters
```

### testing
Testing is as simple as running
```
python -m pytest test/*
```
from the root directory of this project.



# General Repo Layout
The root directory contains the pdf file "Benjamin_Wheeler_BMI203_HW2.pdf", which contains long form answers to the questions posed in part 2 of the assignment
Additionally in this root directory relavant plots are saved that provide analysis of the clustering performed, particularly in reference to answering the hw questions. This directory also contains the pickled object 'legit_hier_clust.obj', which was generated by lines 22 to 24 in \_\_main\_\_.py. 

To perform the analysis required in part two of the assignment, generally running \_\_main\_\_.py is sufficient. However, this depends on whether hierarchical clustering has been performed yet. If hiearchical clustering has not yet been performed this function should be run with lines 22 to 24 and 28 to 32 uncommented. If hierarchical clustering has been performed according to those lines, this time intensive step should be skipped by commenting those lines. The legit_hier_cluster.zip file can be uncompressed and the clustering started by unpickling legit_hier_clust.obj.

Otherwise, clusters contains algs.py which contains all relevant algorithmic implementations. The data folder contains the uncompressed .sdf objects for the ligands. The test folder contains test_clusters.py for testing.


The jupyter notebook "Testing_ground.ipynb" can largely be ignored. This was used for troubleshooting the code contained in algs.py and \_\_main\_\_.py. Many of the homework questions were first done here for a chance to play with the data and test optimal conditions. However, for the code used to generate the plots and answers the reviewer should refer to \_\_main\_\_.py

# Classes and Functions Contained in algs within clusters

## class ligand
This simple class organizes all the import attributes for a ligand into a single object with each held as an attribute
### Parameters

    ligand_string: a string 
    should be formatted as in ligand_information.csv where ID, Score, Smile String, and OnBits are provided separated by commas

### Atributes
    
    ID: string 
        an integer giving a unique identifier to each ligand. treated as a string
    score: float
        the value from the autodock vina run indicating the free energy of binding to a particular protein conformation
    smiles: string
        the smiles string
    OnBits: numpy int array
        this array contains the indices of the OnBits for a particular ligand. (i.e. the compressed form of the chemical representation)


## class HierarchicalClustering

This class will create an object with which has the necessary attributes and functions to perform bottom-up agglomerative hierarchical clustering on a set of provided ligand objects.

### Initialization parameters
    distance_paradigm: string
        at the moment this is not fully functional. The idea was to allow the user to choose between different linkage criteria.
        In the code currently in this repo, 'single_linkage' is always passed. As this is the only linkage criteria currently implemented.
    cluster_number: int
        the number of clusters to identify. For the number of clusters chosen a dendogram matrix is created. This starts with each ligand
        in its own cluster. Then combines two clusters by single linkage until there are as many clusters as indicated by this parameter.
        Given the time to run the algorithm, it is recommended to set this to 1 and create the whole dendogram. Then go to the dendogram
        level that corresponds to the number of clusters desired.
        
### Attributes
     dist_prdgm: string
         this will indicate the linkage criteria to use. This will be properly implemented in future versions of this repo.
         Currently is assumed to be 'single_linkage'
     dendogram: numpy.array
         This is an array that is (number ligands + 1 - number clusters) x number ligands.
         Each row indicates a layer of the dendogram. The clusters are indicated by the number in each column. Columns with the same
         number indicate the same cluster. The number of clusters per row is given by number ligands - row number.
     cluster_number: int
         This indicates the number of clusters get down to by agglomeration
     to_cluster: list of ligand objects
         can be any length list. Must be the ligand objects define in this package for the algorithm to operate properly
     data_expanded: numpy.array
         This is number ligands x OnBit dimension array. It transforms each ligands compact OnBit representation to an 
         'expanded' form with a 0 or 1 at each column indicated by the given OnBit array
     all_distances: numpy.array
         This is an number ligands x number ligands numpy array. It contains the euclidean distance between each pair of 
         ligands
     temp_distances: numpy.array
         This is re-initialized to a number ligands x number ligands array of an arbitrary large number each iteration of the algorithm.
         This is not needed by the user. Used to find the closest existing clusters in each round of the algorithm
         
### function update_cluster
This function resets the number of clusters to find in the algorithm by the number given by the user here
#### parameters
    cluster_number: int

### function get_data
This function takes the list of ligand objects to cluster given by the user and assigns them to the internal variable to_cluster.
This function also uses the given ligands to populate the expanded data_expanded matrix
#### parameters
    objects_to_cluster: list of ligand objects
        Can be any size list of objects. Expects the OnBits to be confined to 1024 dimensions
    
### function calculate_distances
This function is called internally when the cluster function is called by the user. It calls the distance fuction for each ligand pair.
It populates this data into the all_data internal attribute.
#### parameters
    none given besides self

### function single_linkage
This function is called internally to determine distance between clusters for single linkage returns the indices of the current dendogram level to be lumped together
#### parameters
    dendogram_level: int
        this integer indicates the previous, complete layer of the dendogram from which to reference the cluster assignments
#### returns
    numpy.array
        the elements of this array indicate the indices in the previous, complete level of the dendogram which should be lumped together 
        
### function distance
This function determines distance between two ligands, uses euclidian distance, accepts the index in the to_cluster list. Intended to be called internally.
#### parameters
    object_1_index: int
        Indicates the fist object of the pair to find the distance between
    object_2_index: int
        Indicates the second object of the pair to find the distance between
#### returns
    euclid_dist: int
        This value represents the euclidean distance between two ligand objects based upon the OnBits. Range 0-infinity
        
### function cluster
This function is called by the user and performs all the necessary operations to determine the number of clusters as indicated by the internal cluster_number
attribute.
### parameters:
    none
### returns
    nothing is directly returned. The results are held in the dendogram matrix and should be accessed by the user as needed for their application.


## class  PartitionClustering
This class implements vanilla K-means clustering. Pragmatically, the distances used to assign the ligands to the nearest centroid are euclidean distances.
However, the euclidean distances are based upon the similarity scores calculated between each pair of ligands and the ligand itself. 

### Initialization Parameters
    cluster_number: int
        determines the number of clusters to find
    OnBit_Dim: int
        indicate the dimension space of the OnBits so they can be appropriately unpacked
### Attributes
    cluster_number: int
        the number of clusters to find. Also, the number of centroids to initialize
    Bit_Num: int
        the number of dimensions in the OnBits
    to_cluster: list of ligand objects
        can be a list of any size. Must be ligand objects of the class defined in this package
    total_objects: int
        the number of ojbects in to_cluster
    cluster_assignments: 1D numpy array
        This array indicates the cluster to which each ligand is assigned. The order is the same in which the objects were given in to_cluster
        Entries with the same number indicate the same cluster.
    data_expanded: numpy.array
         This is number ligands x OnBit dimension array. It transforms each ligands compact OnBit representation to an 
         'expanded' form with a 0 or 1 at each column indicated by the given OnBit array
    similarity_matrix: numpy.array
        This is a number ligands x number ligands dimension array. For each pair the tanimoto coefficient is determined. This is then used as
        new n x n continuous space with which to cluster the ligands.
    centroids: numpy.array
        This is a number clusters x number ligands numpy array. Each row represents an individual centroid and the columns indicate the location
        in the similarity space
    keep_clustering: boolean
        inialized as true. when false ends the updating procedure for the centroids
    centroids_1back: numpy array
        This is a centroids array simply copied from the last iterration of the loop used to check when to end
    centroids_2back: numpy array
        This is a centroids array simply copied from 2 iterrations past of the loop, used to check when to end

### function get_data
This function takes the list of ligand objects to cluster given by the user and assigns them to the internal variable to_cluster.
This function also uses the given ligands to populate the expanded data_expanded matrix. Finally,the similarity matrix is calculated.
#### parameters
    objects_to_cluster: list of ligand objects
        Can be any size list of objects. Expects the OnBits to be confined to 1024 dimensions

### function create_similarity_matrix
This function goes through each pair of ligands in to_cluster and calculates their similarity by the tanimoto coefficient and assigns this 
to the internal similarity matrix attribute.
#### parameters
    none
    
### function tanamota_coeff
This function determines the similarity of two ligand objects by calculating their tanimoto coefficient. Is cleared spelled wrong, but did not change
so as to save time and chances of breaking the code in places where this function is called.
#### parameters
    object_1: ligand object
        first object to compare
    object_2: ligand object
        second object to compare
#### returns
    int, the intersection/union of the OnBits

### function distance
function to determine distance between two ligands, uses euclidian distance, expects 1D arrays of numerical values. Called internally.
#### parameters
    object_1: 1D numpy.array
        array in similarity space 
    object_2: 1D numpy.array
        array in similarity space
        
#### returns
    euclid_dist: float
        the euclidean distance between two ligands or ligand/centroid pairs

### function initialize_centroids
This function initializes the number of centroids indicated by cluster_number as random ligands in the similarity space
#### parameters
    none, except self
#### returns
    none, assigns centroids to centroid matrix internal attribute
    
### function update_centroids
This function finds the average location of ligands assigned to a given cluster and re-assigns the centroid to that location.
If there is an emtpy cluster the centriod is reassigned to a random ligand in the data set.

#### parameters 
    none,except self
#### returns
    non, assigns new centroids to centroid matrix
    
### function assign_cluster
This function finds the closest centroid to each ligand. It then assigns that centroid number as the cluster for that ligand
#### parameters
    none,except self
#### returns
    non, assigns cluster assignmets to the cluster_assignments internal attribute
    
### function update_cluster_number
This function updates the number of clusters to find
#### parameters
    cluster_number: int
        the new number of clusters to find
#### returns
    none, assignes to internal attribute
    
### function is_cluster_over
This function determines whether to stop the clustering procedure. If the current centroids are the same as either the previous
or 2nd back set of centroids then clustering stops.

#### parameters
    none
#### returns 
    none

### function cluster
This function performs all the necessary steps to execute k-means clustering
#### parameters
    none, besides self
#### returns
    none, clustering result is assigned to cluster_assignments for the user to handle as needed


## function silhouette_score
this defines the silhouette score for a given point
### parameters
    distance_matrix: numpy.array
        should be an array containin euclidean distances between each pair of ligands
    cluster_list: numpy.array
        should be a 1D array that contains the cluster assignments for each ligand
    POI: int
        should be the index in the ligand list of the ligand for which the silhouette score is to be calculated
        
### returns
    score: float
        this is the silhouette score for a single ligand
        

## function Jaccard_Index
Compares the similarity in clustering results by calculating the jaccard index
### parameters
    cluster_list_1: numpy.array
        should be a 1D array where the integer values correspond to cluster assignments
    cluster_list_2: numpy.array
        should be a 1D array where the integer values correspond to cluster assignments
### returns
    jaccard_index: float
        this continuous value defines the similarity of two clustering outcomes. 0 Indicates completely dissimilar clusters. 
        1 indictes identical clusterings

## function euclid_distance
This function takes a similarity matrix and creates a euclidean distance matrix based upon that
### parameters
    similarity_matrix: numpy.array
        This should be number ligands x number ligands. This function will create a distance matrix using each column as a new continous dimension
### returns
    distance_matrix: numpy.array
        This is a number_ligands x number ligands array. This contains the euclidean distance between each pair of ligands in the similarity space

## function closest_cluster
This function finds the cluster that is closest to the given ligand that is not contained within the ligands home cluster
### parameters
    distance_matrix: numpy.array
        this is the pairwise euclidean distance matrix between pairs of ligands in the similarity space
    cluster_list: numpy.array
        a 1D array of values which corresponds to the cluster label for all the ligands.
    ligand_index: int
        the index in the cluster_list of the ligand of interest to find the closest cluster

### returns 
    close_cluster: int,
        the cluster label of the cluster closest to the ligand of interest